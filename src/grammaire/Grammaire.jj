options{  DEBUG_PARSER = false;  STATIC = false;}PARSER_BEGIN(Compiler)package grammaire;import java.io.*;import java.util.*;import instructions.operations.*;import instructions.adressages.*;import instructions.Operande;import java.lang.reflect.Constructor;public class Compiler{  /** Compilation d'un fichier de combattant  * @param s : le nom du fichier  * @throws Exception une erreur de lecture  */  public static List < Instruction > compile(String s) throws Exception  {    FileReader r = new FileReader(s);    Compiler parser = new Compiler(new BufferedReader(r));    List < Instruction > code = parser.INSTRUCTIONS();    return code;  }  /** rÃƒÂ©alignement en cas dÃ¢Â€Â™erreur de syntaxe sur le symbole EOL*/  private void skiptoEOL()  {    while (token.kind != EOL || token.kind != CEOL) getNextToken();  }}PARSER_END(Compiler)// les caractÃƒÅ¡res ignorÃƒÂ©s SKIP :{  " "| "\t"| "\""| "\\"| "!"| "%"| "&"| "'"| "*"| "."| "/"| ";"| "<"| ">"| "="| "?"| "["| "]"| "^"| "`"| "{"| "}"| "~"| "|"| "Ã‚Âµ"| "Ã‚Â§"| "\00"| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""| ""}// Les lexeÃŒÂ€mes de fin de ligneTOKEN :{  < EOL :    "\n"  | "\r"  | "\r\n" >}// La gestion des commentairesSPECIAL_TOKEN :{  "//" : IN_SL_COMMENT}< IN_SL_COMMENT >TOKEN :{  < CEOL : < EOL >> : DEFAULT}< IN_SL_COMMENT >SKIP :{  < ~[ ] >}/*Adressage*/TOKEN :{  < IMM : "#" >| < NUM : "$" >| < IND : "@" >}TOKEN :{  < PLUS : "+" >| < MOINS : "-" >| < VALUE : (< DIGIT >)+ >| < #LETTER : [ "a"-"z", "A"-"Z" ] >| < #DIGIT : [ "0"-"9" ] >}/* INSTRUCTIONS */TOKEN :{  < DAT : "DAT" >| < MOV : "MOV" >| < ADD : "ADD" >| < SUB : "SUB" >| < MUL : "MUL" >| < DIV : "DIV" >| < MOD : "MOD" >| < JMP : "JMP" >| < JMZ : "JMZ" >| < JMN : "JMN" >| < DJN : "DJN" >| < CMP : "CMP" >| < CLT : "CLT" >}//  les rÃƒÅ¡gles de grammaire de ce langage List < Instruction > INSTRUCTIONS() throws Exception :{  List < Instruction > inst = new ArrayList < Instruction > ();  Instruction courante;}{  (    courante = INSTRUCTION() < EOL >    {   inst.add(courante);  }  )*  < EOF >  {    return inst;  }}Instruction INSTRUCTION() throws Exception :{  Token operation;  Operande operande1;  Operande operande2;}{  operation = < DAT > operande1 = operande()  {return new Dat(operande1);}| operation = < MOV > operande1 = operande() operande2 = operande()  {}| operation = < ADD > operande1 = operande() operande2 = operande()  {return new Add(operande1, operande2); }| operation = < SUB > operande1 = operande() operande2 = operande()  {return new Sub(operande1, operande2);}| operation = < MUL > operande1 = operande() operande2 = operande()  {return new Mul(operande1, operande2);}| operation = < DIV > operande1 = operande() operande2 = operande()  {return new Div(operande1, operande2);}| operation = < MOD > operande1 = operande() operande2 = operande()  {return new Mod(operande1, operande2);}| operation = < JMP > operande1 = operande()  {return new Jmp(operande1);}| operation = < JMZ > operande1 = operande() operande2 = operande()  {return new Jmz(operande1, operande2);}| operation = < JMN > operande1 = operande() operande2 = operande()  {return new Jmn(operande1, operande2);}| operation = < DJN > operande1 = operande() operande2 = operande()  {return new Djn(operande1, operande2);}| operation = < CMP > operande1 = operande() operande2 = operande()  {return new Cmp(operande1, operande2);}| operation = < CLT > operande1 = operande() operande2 = operande(){}}Operande operande() :{  Token op;  Integer val;}{  (    op = < IMM >  | op = < NUM >  | op = < IND >  )  val = ENTIER()  {    switch (op.kind) {      case IMM :      {return new Operande(new Immediat(), val);  break; }      case NUM :      {return new Operande(new Relatif(), val);  break; }      case IND :       { return new Operande(new RelatifIndirect(), val); break;} }  }| val = ENTIER()  {    return new Operande(new Relatif(), val);  }}Integer ENTIER() :{  Token valeur, signe;}{  < PLUS > valeur = < VALUE >  {    return Integer.parseInt(valeur.image);  }| < MOINS > valeur = < VALUE >  {    return - Integer.parseInt(valeur.image);  }| valeur = < VALUE >  {    return Integer.parseInt(valeur.image);  }}